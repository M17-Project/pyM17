"""M17 BERT (Bit Error Rate Test) Frame Support

BERT frames are used for testing RF link quality by transmitting a known
pseudo-random bit sequence and measuring bit errors at the receiver.

BERT Frame Structure:
- Sync word: 0xDF55 (SYNC_BERT)
- Payload: 25 bytes (197 bits used) of pseudo-random data
- FEC: Convolutional encoding with P2 puncturing

The pseudo-random sequence is generated using a maximal-length LFSR,
allowing the receiver to synchronize and detect errors.

Example:
-------
    # Generate BERT frame
    bert = BERTFrame.generate(seed=0x1234)
    rf_data = bert.encode_for_rf()

    # At receiver - calculate BER
    received = BERTFrame.from_rf(rf_data)
    expected = BERTFrame.generate(seed=0x1234)
    ber = received.calculate_ber(expected)
    print(f"BER: {ber:.2%}")
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional

from m17.core.constants import SYNC_BERT

__all__ = [
    "BERTFrame",
    "BERTGenerator",
    "calculate_ber",
]

# BERT payload size
BERT_PAYLOAD_BYTES = 25
BERT_PAYLOAD_BITS = 197  # Only 197 of 200 bits are used

# LFSR polynomial for BERT sequence (x^9 + x^5 + 1)
# This is a standard PRBS-9 pattern used in communications testing
BERT_LFSR_POLY = 0x110  # Taps at bits 9 and 5


@dataclass
class BERTGenerator:
    """BERT pseudo-random sequence generator.

    Uses a 9-bit LFSR (PRBS-9) to generate the test pattern.
    The same seed must be used at transmitter and receiver.

    Example:
    -------
        gen = BERTGenerator(seed=0x1FF)  # All ones seed
        pattern = gen.generate_bytes(25)
    """

    seed: int = 0x1FF  # Default: all ones (9-bit)
    _state: int = field(init=False)

    def __post_init__(self) -> None:
        """Initialize LFSR state."""
        self._state = self.seed & 0x1FF
        if self._state == 0:
            self._state = 1  # Avoid lockup

    def reset(self) -> None:
        """Reset generator to initial seed."""
        self._state = self.seed & 0x1FF
        if self._state == 0:
            self._state = 1

    def _step(self) -> int:
        """Generate one bit and advance LFSR.

        Returns
        -------
            Output bit (0 or 1).
        """
        # Output is LSB
        output = self._state & 1

        # Feedback from bits 9 and 5 (1-indexed)
        feedback = ((self._state >> 8) ^ (self._state >> 4)) & 1

        # Shift right, insert feedback at MSB
        self._state = ((self._state >> 1) | (feedback << 8)) & 0x1FF

        return output

    def generate_bits(self, count: int) -> list[int]:
        """Generate specified number of bits.

        Args:
        ----
            count: Number of bits to generate.

        Returns:
        -------
            List of bits (0s and 1s).
        """
        return [self._step() for _ in range(count)]

    def generate_bytes(self, count: int) -> bytes:
        """Generate specified number of bytes.

        Args:
        ----
            count: Number of bytes to generate.

        Returns:
        -------
            Generated bytes.
        """
        result = bytearray(count)
        for i in range(count):
            byte_val = 0
            for _ in range(8):
                byte_val = (byte_val << 1) | self._step()
            result[i] = byte_val
        return bytes(result)


@dataclass
class BERTFrame:
    """M17 BERT (Bit Error Rate Test) Frame.

    Used for testing RF link quality by transmitting a known pattern.

    Attributes
    ----------
        payload: 25-byte BERT payload (197 bits used).
        seed: LFSR seed used to generate payload.
    """

    payload: bytes = field(default_factory=lambda: bytes(BERT_PAYLOAD_BYTES))
    seed: int = 0x1FF

    def __post_init__(self) -> None:
        """Validate payload size."""
        if len(self.payload) < BERT_PAYLOAD_BYTES:
            # Pad with zeros
            self.payload = self.payload + bytes(BERT_PAYLOAD_BYTES - len(self.payload))
        elif len(self.payload) > BERT_PAYLOAD_BYTES:
            # Truncate
            self.payload = self.payload[:BERT_PAYLOAD_BYTES]

    @classmethod
    def generate(cls, seed: int = 0x1FF) -> BERTFrame:
        """Generate a BERT frame with pseudo-random payload.

        Args:
        ----
            seed: LFSR seed (9-bit, default 0x1FF).

        Returns:
        -------
            BERTFrame with generated payload.
        """
        gen = BERTGenerator(seed=seed)
        payload = gen.generate_bytes(BERT_PAYLOAD_BYTES)
        return cls(payload=payload, seed=seed)

    @property
    def sync_word(self) -> int:
        """BERT frame sync word."""
        return SYNC_BERT

    def get_bits(self) -> list[int]:
        """Get payload as 197 bits.

        Returns
        -------
            List of 197 bits.
        """
        bits = []
        for i in range(BERT_PAYLOAD_BITS):
            byte_idx = i // 8
            bit_idx = 7 - (i % 8)
            bits.append((self.payload[byte_idx] >> bit_idx) & 1)
        return bits

    def encode_for_rf(self) -> bytes:
        """Encode frame for RF transmission.

        Applies convolutional encoding with P2 puncturing.

        Returns
        -------
            Encoded frame data (includes sync word).
        """
        from m17.codec.convolutional import conv_encode_bert
        from m17.codec.interleave import interleave
        from m17.codec.puncture import puncture_bert
        from m17.codec.randomize import randomize

        # Convolutional encode
        encoded = conv_encode_bert(self.payload)

        # Puncture (may produce 369 bits due to rounding, truncate to 368)
        punctured = puncture_bert(encoded)[:368]

        # Interleave
        interleaved = interleave(punctured)

        # Randomize
        randomized = randomize(interleaved)

        # Pack bits to bytes
        frame_bytes = bytearray(46)
        for i in range(368):
            byte_idx = i // 8
            bit_idx = 7 - (i % 8)
            if randomized[i]:
                frame_bytes[byte_idx] |= 1 << bit_idx

        # Prepend sync word
        sync_bytes = self.sync_word.to_bytes(2, "big")
        return sync_bytes + bytes(frame_bytes)

    @classmethod
    def from_rf(cls, data: bytes, seed: int = 0x1FF) -> Optional[BERTFrame]:
        """Decode BERT frame from RF data.

        Applies FEC decoding to recover payload.

        Args:
        ----
            data: RF frame data (48 bytes with sync).
            seed: Expected LFSR seed for BER calculation.

        Returns:
        -------
            Decoded BERTFrame, or None if decoding fails.
        """
        from m17.codec.interleave import deinterleave
        from m17.codec.puncture import depuncture_stream
        from m17.codec.randomize import derandomize
        from m17.codec.viterbi import viterbi_decode

        if len(data) < 48:
            return None

        # Check sync word
        sync = int.from_bytes(data[:2], "big")
        if sync != SYNC_BERT:
            return None

        # Unpack bits
        frame_bytes = data[2:48]
        bits = []
        for i in range(368):
            byte_idx = i // 8
            bit_idx = 7 - (i % 8)
            bits.append((frame_bytes[byte_idx] >> bit_idx) & 1)

        # Derandomize
        derandomized = derandomize(bits)

        # Deinterleave
        deinterleaved = deinterleave(derandomized)

        # Depuncture (soft decision placeholder - use hard bits as soft)
        soft_bits = [0x0000 if b else 0xFFFF for b in deinterleaved]
        depunctured = depuncture_stream(soft_bits)

        # Viterbi decode - returns (decoded_bytes, metric)
        decoded_bytes, _ = viterbi_decode(depunctured)

        # Use decoded bytes directly as payload (take first 25 bytes)
        payload = decoded_bytes[:BERT_PAYLOAD_BYTES]
        if len(payload) < BERT_PAYLOAD_BYTES:
            payload = payload + bytes(BERT_PAYLOAD_BYTES - len(payload))

        return cls(payload=payload, seed=seed)

    def calculate_ber(self, reference: BERTFrame) -> float:
        """Calculate Bit Error Rate against a reference frame.

        Args:
        ----
            reference: Expected BERT frame (from same seed).

        Returns:
        -------
            BER as a fraction (0.0 to 1.0).
        """
        received_bits = self.get_bits()
        expected_bits = reference.get_bits()

        errors = sum(r != e for r, e in zip(received_bits, expected_bits, strict=False))
        return errors / BERT_PAYLOAD_BITS

    def count_errors(self, reference: BERTFrame) -> int:
        """Count bit errors against a reference frame.

        Args:
        ----
            reference: Expected BERT frame.

        Returns:
        -------
            Number of bit errors.
        """
        received_bits = self.get_bits()
        expected_bits = reference.get_bits()
        return sum(r != e for r, e in zip(received_bits, expected_bits, strict=False))

    def __bytes__(self) -> bytes:
        """Return payload bytes."""
        return self.payload

    def __eq__(self, other: object) -> bool:
        """Compare BERT frames."""
        if isinstance(other, BERTFrame):
            return self.payload == other.payload
        if isinstance(other, bytes):
            return self.payload == other
        return NotImplemented


def calculate_ber(received: bytes, expected: bytes, num_bits: Optional[int] = None) -> float:
    """Calculate Bit Error Rate between two byte sequences.

    Args:
    ----
        received: Received data.
        expected: Expected data.
        num_bits: Number of bits to compare (default: all).

    Returns:
    -------
        BER as a fraction (0.0 to 1.0).

    Example:
    -------
        ber = calculate_ber(received_payload, expected_payload)
        print(f"BER: {ber:.4%}")
    """
    if len(received) != len(expected):
        raise ValueError("Received and expected must be same length")

    total_bits = len(received) * 8
    if num_bits is not None:
        total_bits = min(total_bits, num_bits)

    errors = 0
    for i in range(total_bits):
        byte_idx = i // 8
        bit_idx = 7 - (i % 8)
        r_bit = (received[byte_idx] >> bit_idx) & 1
        e_bit = (expected[byte_idx] >> bit_idx) & 1
        if r_bit != e_bit:
            errors += 1

    return errors / total_bits if total_bits > 0 else 0.0
